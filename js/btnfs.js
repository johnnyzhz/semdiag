




/***************************************************
 * semdiag: draw SEM path diagram interactively    *
 * Authors: Yujiao Mai, Zhiyong Zhang, Ke-Hai Yuan *
 * Copyright 2015-2015, psychstat.org              *
 * Licensed under the MIT License (MIT)            *
 * Current software version 1.0                    *
 * Support email for questions zzhang4@nd.edu      *
 *                             ymai@nd.edu         * 
 ***************************************************/

// update 2021-June 20 - fix save diagram/html/svg to html




 function ResetButtonStatus() {
    svgstatus.linkingto >= 1 && (svgstatus.linkingto = 0, linkinginitialindex = -1, linkingtargetindex = -1, linkingtoArrowTYPE = "uni", svgdragline = {
        x0: 0,
        y0: 0,
        x1: 0,
        y1: 0
    }), 1 === svgstatus.texting && (svgstatus.texting = 0), 1 === svgstatus.drawingline && (svgstatus.drawingline = 0, svgdragline2 = {
        x0: 0,
        y0: 0,
        x1: 0,
        y1: 0
    }), 1 === svgstatus.multipleselecting && (svgstatus.multipleselecting = 0, multipleselectframe = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    })
}

function BTNrect() {
    ResetButtonStatus();
    node_add(newnodeInitialPos_rect, default_RADIUSH, default_RADIUSV, "rect");
    newnodeInitialPos_rect.x - nodeInitialPos_rect.x >= loopTagger_newnode * default_RADIUSH ? newnodeInitialPos_rect.x = nodeInitialPos_rect.x : newnodeInitialPos_rect.x = newnodeInitialPos_rect.x + default_RADIUSH, newnodeInitialPos_rect.y - nodeInitialPos_rect.y >= loopTagger_newnode * default_RADIUSV ? newnodeInitialPos_rect.y = nodeInitialPos_rect.y : newnodeInitialPos_rect.y = newnodeInitialPos_rect.y + default_RADIUSV, updatesvg()
}

function BTNellipse() {
    ResetButtonStatus();
    var a = node_add(newnodeInitialPos_ellipse, default_RADIUSH, default_RADIUSV, "ellipse");
    newnodeInitialPos_ellipse.x - nodeInitialPos_ellipse.x >= loopTagger_newnode * default_RADIUSH ? newnodeInitialPos_ellipse.x = nodeInitialPos_ellipse.x : newnodeInitialPos_ellipse.x = newnodeInitialPos_ellipse.x + default_RADIUSH, newnodeInitialPos_ellipse.y - nodeInitialPos_ellipse.y >= loopTagger_newnode * default_RADIUSV ? newnodeInitialPos_ellipse.y = nodeInitialPos_ellipse.y : newnodeInitialPos_ellipse.y = newnodeInitialPos_ellipse.y + default_RADIUSV, newnodeindex = matchnodeindex(nodes, a.id), edge_add(newnodeindex, newnodeindex, "bi"), updatesvg()
}

function BTNtriangle() {
    if (ResetButtonStatus(), 1 === svgstatus.nodeselected) {
        for (var a = 0; a < selectednodeindexes.length; a++) {
            tselectednodeindex = selectednodeindexes[a];
            var b = nodes[tselectednodeindex];
            if ("rect" === b.type || "ellipse" === b.type) {
                0 === numTri && (tnodeInitialPos = {
                    x: nodeInitialPos.x - 2 * default_RADIUSH,
                    y: nodeInitialPos.y - default_RADIUSV
                }, theTriangle = node_add(tnodeInitialPos, default_RADIUSH, default_RADIUSV, "triangle"));
                var c = generate_edge(nodes, theTriangle.id, b.id, "uni"),
                    d = lookfor_duplicatedbcurve(nodes, edges, c.startid, c.endid, "uni");
                if (d >= 0);
                else {
                    var e = generate_tangent(nodes, c);
                    edges.push(c), numEdge++, edges_tangents.push(e)
                }
            }
        }
        updatesvg()
    }
}

function BTNlinkingto() {
    ResetButtonStatus(), linkingtoArrowTYPE = "uni";
    var a = [];
    if (1 === svgstatus.edgeselected)
        for (var b = 0; b < selectededgeindexes.length; b++) {
            var c = selectededgeindexes[b],
                d = edges[c].id;
            a.push(d)
        }
    if (1 === svgstatus.edgeselected) {
        for (var b = 0; b < selectededgeindexes.length; b++) {
            var c = matchedgeindex(edges, a[b]);
            if (c >= 0 & c < edges.length) {
                var e = edges[c];
                if (e.type != linkingtoArrowTYPE)
                    if (2 === e.power) {
                        edges[c].type = linkingtoArrowTYPE;
                        var f = matchnodeindex(nodes, e.startid),
                            g = matchnodeindex(nodes, e.endid);
                        if (e.labelInitial) {
                            var h = generate_label(nodes[f], nodes[g], "uni", 2);
                            edges[c].label = h
                        }
                        if ("triangle" === nodes[f].type);
                        else {
                            var i = edge_add(g, g, "bi");
                            i >= 0 & i < edges.length && (edges[i].IsAutoGenerated = !0)
                        }
                    } else 3 == e.power
            }
        }
        EdgesUnselected(), updatesvg()
    } else if (1 === svgstatus.nodeselected) {
        if (1 == selectednodeindexes.length) {
            var j = selectednodeindexes[0];
            j >= 0 & j < nodes.length && (svgstatus.linkingto = 2, linkinginitialindex = j)
        }
    } else svgstatus.linkingto = 1, updatesvg()
}

function BTNlinkingto2() {
    ResetButtonStatus(), linkingtoArrowTYPE = "bi";
    var a = [];
    if (1 === svgstatus.edgeselected)
        for (var b = 0; b < selectededgeindexes.length; b++) {
            var c = selectededgeindexes[b],
                d = edges[c].id;
            a.push(d)
        }
    if (1 === svgstatus.edgeselected) {
        for (var b = 0; b < selectededgeindexes.length; b++) {
            var c = matchedgeindex(edges, a[b]);
            if (c >= 0 & c < edges.length) {
                var e = edges[c];
                if (e.type != linkingtoArrowTYPE)
                    if (2 === e.power) {
                        var f = nodes[matchnodeindex(nodes, e.startid)],
                            g = nodes[matchnodeindex(nodes, e.endid)];
                        if ("triangle" === f.type);
                        else {
                            if (edges[c].type = linkingtoArrowTYPE, e.labelInitial) {
                                var h = generate_label(f, g, "bi", 2);
                                edges[c].label = h
                            }
                            delete_nonuseedges(edges[c].startid, edges[c].endid, linkingtoArrowTYPE)
                        }
                    } else 3 === e.power
            }
        }
        EdgesUnselected(), updatesvg()
    } else 1 === svgstatus.nodeselected ? 1 == selectednodeindexes.length && selectednodeindex >= 0 & selectednodeindex < nodes.length && (svgstatus.linkingto = 2, linkinginitialindex = selectednodeindex) : svgstatus.linkingto = 1
}

function BTNtexting() {
    if (ResetButtonStatus(), 1 === svgstatus.nodeselected || 1 === svgstatus.edgeselected || 1 === svgstatus.noteselected) {
        if (1 === svgstatus.nodeselected) {
            var a = selectednodeindex,
                b = nodes[a];
            node_text_editing(b)
        } else if (1 === svgstatus.edgeselected) {
            var a = selectededgeindex,
                b = edges[a];
            bcurve_text_editing(b, a)
        } else if (1 === svgstatus.noteselected) {
            var a = selectednoteindex,
                b = notes[a];
            note_text_editing(b, a)
        }
        updatesvg()
    } else svgstatus.texting = 1
}

function BTNdel() {
    ResetButtonStatus();
    var a = [],
        b = [];
    if (1 === svgstatus.edgeselected)
        for (var d = 0; d < selectededgeindexes.length; d++) {
            var e = selectededgeindexes[d],
                f = edges[e].id;
            a.push(f)
        }
    if (1 === svgstatus.nodeselected)
        for (var d = 0; d < selectednodeindexes.length; d++) {
            var g = selectednodeindexes[d],
                f = nodes[g].id;
            b.push(f)
        }
    if (1 === svgstatus.edgeselected) {
        for (var d = 0; d < selectededgeindexes.length; d++) {
            var e = matchedgeindex(edges, a[d]);
            if (e >= 0 & e < edges.length) {
                var h = e;
                edge_delete(h)
            }
        }
        EdgesUnselected()
    }
    if (1 === svgstatus.nodeselected) {
        for (var d = 0; d < selectednodeindexes.length; d++) {
            var g = -1;
            if (g = matchnodeindex(nodes, b[d]), g >= 0 & g < nodes.length) {
                var i = g;
                node_delete(i)
            }
        }
        NodesUnselected()
    }
    if (1 === svgstatus.noteselected) {
        selectednoteindexes.sort(function (a, b) {
            return b - a
        });
        for (var d = 0; d < selectednoteindexes.length; d++) {
            var j = selectednoteindexes[d];
            if (j >= 0 & j < notes.length) {
                var k = j;
                note_delete(k)
            }
        }
        NotesUnselected()
    }
    updatesvg()
}

function BTNclone() {
    ResetButtonStatus();
    var a = default_RADIUSV,
        b = default_RADIUSH,
        c = [],
        d = [];
    if (1 === svgstatus.nodeselected) {
        selectednodeindexes.sort(function (a, b) {
            return a - b
        });
        for (var e = 0; e < selectednodeindexes.length; e++) {
            var f = selectednodeindexes[e];
            if (f >= 0 & f < nodes.length) {
                var g = nodes[f];
                if ("triangle" === g.type) d.push(g), c.push(g);
                else {
                    var i = node_copy(g);
                    null == i || (i.x = g.x + a, i.y = g.y + b, d.push(i), nodes[matchnodeindex(nodes, i.id)] = i, c.push(g))
                }
            }
        }
    }
    var j = [],
        k = [];
    if (1 === svgstatus.edgeselected) {
        selectededgeindexes.sort(function (a, b) {
            return a - b
        });
        for (var e = 0; e < selectededgeindexes.length; e++) {
            var l = selectededgeindexes[e];
            if (l >= 0 & l < edges.length) {
                var m = edges[l],
                    n = matchnodeindex(c, m.startid),
                    o = matchnodeindex(c, m.endid);
                if (n != -1 & o != -1) {
                    var p = generate_edge(d, d[n].id, d[o].id, m.type);
                    if ("triangle" === d[n].type || (p.handleP = {
                            x: m.handleP.x + a,
                            y: m.handleP.y + b
                        }, p.labelP = {
                            x: m.labelP.x + a,
                            y: m.labelP.y + b
                        }), p.dotted = m.dotted, p.color = m.color, p.strokewidth = m.strokewidth, p.label = m.label, p.labelFsize = m.labelFsize, p.labelshow = m.labelshow, p.handleshow = !1, p.handleInitial = m.handleInitial, p.IsAutoGenerated = m.IsAutoGenerated, p.curve_LR = m.curve_LR, p.selected = !0, p = update_bcurve(d, p), null == p);
                    else {
                        edge_add_newbcurve(p);
                        k.push(p), j.push(m)
                    }
                }
            }
        }
    }
    var r = AdjustChartSize(nodes, edges, edges_tangents, notes);
    r.w > w && (w = r.w), r.h > h && (h = r.h), 1 === svgstatus.nodeselected && NodesUnselected(), 1 === svgstatus.edgeselected && EdgesUnselected(), 1 === svgstatus.noteselected && NotesUnselected();
    for (var e = 0; e < d.length; e++) tindex = matchnodeindex(nodes, d[e].id), selectednodeindexes.push(tindex), selectednodeindex = tindex;
    selectednodeindexes.length >= 1 && (svgstatus.nodeselected = 1);
    for (var e = 0; e < k.length; e++) tindex = matchedgeindex(edges, k[e].id), selectededgeindexes.push(tindex), selectededgeindex = tindex;
    selectededgeindexes.length >= 1 && (svgstatus.edgeselected = 1), updatesvg()
}

function BTNred() {
    ResetButtonStatus();
    var a = "RED";
    if (1 === svgstatus.edgeselected)
        for (var b = 0; b < selectededgeindexes.length; b++) {
            var c = selectededgeindexes[b];
            c >= 0 & c < edges.length && (edges[c].color = a)
        }
    if (1 === svgstatus.nodeselected)
        for (var b = 0; b < selectednodeindexes.length; b++) {
            var d = selectednodeindexes[b];
            d >= 0 & d < nodes.length && (nodes[d].color = a)
        }
    if (1 === svgstatus.noteselected)
        for (var b = 0; b < selectednoteindexes.length; b++) {
            var e = selectednoteindexes[b];
            e >= 0 & e < notes.length && (notes[e].color = a)
        }
    updatesvg()
}

function BTNblue() {
    ResetButtonStatus();
    var a = "BLUE";
    if (1 === svgstatus.edgeselected)
        for (var b = 0; b < selectededgeindexes.length; b++) {
            var c = selectededgeindexes[b];
            c >= 0 & c < edges.length && (edges[c].color = a)
        }
    if (1 === svgstatus.nodeselected)
        for (var b = 0; b < selectednodeindexes.length; b++) {
            var d = selectednodeindexes[b];
            d >= 0 & d < nodes.length && (nodes[d].color = a)
        }
    if (1 === svgstatus.noteselected)
        for (var b = 0; b < selectednoteindexes.length; b++) {
            var e = selectednoteindexes[b];
            e >= 0 & e < notes.length && (notes[e].color = a)
        }
    updatesvg()
}

function BTNgreen() {
    ResetButtonStatus();
    var a = "GREEN";
    if (1 === svgstatus.edgeselected)
        for (var b = 0; b < selectededgeindexes.length; b++) {
            var c = selectededgeindexes[b];
            c >= 0 & c < edges.length && (edges[c].color = a)
        }
    if (1 === svgstatus.nodeselected)
        for (var b = 0; b < selectednodeindexes.length; b++) {
            var d = selectednodeindexes[b];
            d >= 0 & d < nodes.length && (nodes[d].color = a)
        }
    if (1 === svgstatus.noteselected)
        for (var b = 0; b < selectednoteindexes.length; b++) {
            var e = selectednoteindexes[b];
            e >= 0 & e < notes.length && (notes[e].color = a)
        }
    updatesvg()
}

function BTNblack() {
    ResetButtonStatus();
    var a = "BLACK";
    if (1 === svgstatus.edgeselected)
        for (var b = 0; b < selectededgeindexes.length; b++) {
            var c = selectededgeindexes[b];
            c >= 0 & c < edges.length && (edges[c].color = a)
        }
    if (1 === svgstatus.nodeselected)
        for (var b = 0; b < selectednodeindexes.length; b++) {
            var d = selectednodeindexes[b];
            d >= 0 & d < nodes.length && (nodes[d].color = a)
        }
    if (1 === svgstatus.noteselected)
        for (var b = 0; b < selectednoteindexes.length; b++) {
            var e = selectednoteindexes[b];
            e >= 0 & e < notes.length && (notes[e].color = a)
        }
    updatesvg()
}

function BTNsolid() {
    if (ResetButtonStatus(), 1 === svgstatus.edgeselected)
        for (var a = 0; a < selectededgeindexes.length; a++) {
            var b = selectededgeindexes[a];
            b >= 0 & b < edges.length && (edges[b].dotted = 0)
        }
    if (1 === svgstatus.nodeselected)
        for (var a = 0; a < selectednodeindexes.length; a++) {
            var c = selectednodeindexes[a];
            c >= 0 & c < nodes.length && (nodes[c].dotted = 0)
        }
    updatesvg()
}

function BTNdotted() {
    if (ResetButtonStatus(), 1 === svgstatus.edgeselected)
        for (var a = 0; a < selectededgeindexes.length; a++) {
            var b = selectededgeindexes[a];
            b >= 0 & b < edges.length && (edges[b].dotted = 1)
        }
    if (1 === svgstatus.nodeselected)
        for (var a = 0; a < selectednodeindexes.length; a++) {
            var c = selectednodeindexes[a];
            c >= 0 & c < nodes.length && (nodes[c].dotted = 1)
        }
    updatesvg()
}

function BTNla() {
    ResetButtonStatus(), svgstatus.IsShowLabels = !svgstatus.IsShowLabels, oBTN = document.getElementById("BTNLaimage"), svgstatus.IsShowLabels ? oBTN.src = "./img/La.png" : oBTN.src = "./img/La1.png", updatesvg()
}

function BTNgrid() {
    ResetButtonStatus(), svgstatus.IsShowGrid = !svgstatus.IsShowGrid, updatesvg()
}

function BTNalignleft() {
    if (ResetButtonStatus(), 1 === svgstatus.nodeselected) {
        for (var a = nodes[selectednodeindexes[0]].x - nodes[selectednodeindexes[0]].rx, b = [], c = 0; c < selectednodeindexes.length; c++) {
            var d = selectednodeindexes[c],
                e = {
                    x: nodes[d].x,
                    y: nodes[d].y
                };
            b.push(e);
            var f = nodes[d].x - nodes[d].rx;
            a > f && (a = f)
        }
        for (var c = 0; c < selectednodeindexes.length; c++) {
            var d = selectednodeindexes[c];
            nodes[d].x = a + nodes[d].rx
        }
        for (var c = 0; c < selectednodeindexes.length; c++) {
            var d = selectednodeindexes[c];
            update_edge_with_moved_node(nodes[d], b[c])
        }
    }
    updatesvg()
}

function BTNalignright() {
    if (ResetButtonStatus(), 1 === svgstatus.nodeselected) {
        for (var a = nodes[selectednodeindexes[0]].x + nodes[selectednodeindexes[0]].rx, b = [], c = 0; c < selectednodeindexes.length; c++) {
            var d = selectednodeindexes[c],
                e = {
                    x: nodes[d].x,
                    y: nodes[d].y
                };
            b.push(e);
            var f = nodes[d].x + nodes[d].rx;
            a < f && (a = f)
        }
        for (var c = 0; c < selectednodeindexes.length; c++) {
            var d = selectednodeindexes[c];
            nodes[d].x = a - nodes[d].rx
        }
        for (var c = 0; c < selectednodeindexes.length; c++) {
            var d = selectednodeindexes[c];
            update_edge_with_moved_node(nodes[d], b[c])
        }
    }
    updatesvg()
}

function BTNaligntop() {
    if (ResetButtonStatus(), 1 === svgstatus.nodeselected) {
        for (var a = nodes[selectednodeindexes[0]].y - nodes[selectednodeindexes[0]].ry, b = [], c = 0; c < selectednodeindexes.length; c++) {
            var d = selectednodeindexes[c],
                e = {
                    x: nodes[d].x,
                    y: nodes[d].y
                };
            b.push(e);
            var f = nodes[d].y - nodes[d].ry;
            a > f && (a = f)
        }
        for (var c = 0; c < selectednodeindexes.length; c++) {
            var d = selectednodeindexes[c];
            nodes[d].y = a + nodes[d].ry
        }
        for (var c = 0; c < selectednodeindexes.length; c++) {
            var d = selectednodeindexes[c];
            update_edge_with_moved_node(nodes[d], b[c])
        }
    }
    updatesvg()
}

function BTNalignbottom() {
    if (ResetButtonStatus(), 1 === svgstatus.nodeselected) {
        for (var a = nodes[selectednodeindexes[0]].y + nodes[selectednodeindexes[0]].ry, b = [], c = 0; c < selectednodeindexes.length; c++) {
            var d = selectednodeindexes[c],
                e = {
                    x: nodes[d].x,
                    y: nodes[d].y
                };
            b.push(e);
            var f = nodes[d].y + nodes[d].ry;
            a < f && (a = f)
        }
        for (var c = 0; c < selectednodeindexes.length; c++) {
            var d = selectednodeindexes[c];
            nodes[d].y = a - nodes[d].ry
        }
        for (var c = 0; c < selectednodeindexes.length; c++) {
            var d = selectednodeindexes[c];
            update_edge_with_moved_node(nodes[d], b[c])
        }
    }
    updatesvg()
}

function BTNmoveup() {
    if (ResetButtonStatus(), 1 === svgstatus.nodeselected) {
        for (var a = [], b = 0; b < selectednodeindexes.length; b++) {
            var c = selectednodeindexes[b],
                d = {
                    x: nodes[c].x,
                    y: nodes[c].y
                };
            a.push(d)
        }
        for (var b = 0; b < selectednodeindexes.length; b++) {
            var c = selectednodeindexes[b];
            nodes[c].y - nodes[c].ry >= 1 && (nodes[c].y = nodes[c].y - 1)
        }
        for (var b = 0; b < selectednodeindexes.length; b++) {
            var c = selectednodeindexes[b];
            update_edge_with_moved_node(nodes[c], a[b])
        }
    }
    if (1 === svgstatus.noteselected)
        for (var b = 0; b < selectednoteindexes.length; b++) {
            var c = selectednoteindexes[b];
            notes[c].y >= 1 && (notes[c].y = notes[c].y - 1)
        }
    updatesvg()
}

function BTNmovedown() {
    if (ResetButtonStatus(), 1 === svgstatus.nodeselected) {
        for (var a = [], b = 0; b < selectednodeindexes.length; b++) {
            var c = selectednodeindexes[b],
                d = {
                    x: nodes[c].x,
                    y: nodes[c].y
                };
            a.push(d)
        }
        for (var b = 0; b < selectednodeindexes.length; b++) {
            var c = selectednodeindexes[b];
            nodes[c].y + nodes[c].ry <= h - 1 && (nodes[c].y = nodes[c].y + 1)
        }
        for (var b = 0; b < selectednodeindexes.length; b++) {
            var c = selectednodeindexes[b];
            update_edge_with_moved_node(nodes[c], a[b])
        }
    }
    if (1 === svgstatus.noteselected)
        for (var b = 0; b < selectednoteindexes.length; b++) {
            var c = selectednoteindexes[b];
            notes[c].y <= h - 1 && (notes[c].y = notes[c].y + 1)
        }
    updatesvg()
}

function BTNmoveleft() {
    if (ResetButtonStatus(), 1 === svgstatus.nodeselected) {
        for (var a = [], b = 0; b < selectednodeindexes.length; b++) {
            var c = selectednodeindexes[b],
                d = {
                    x: nodes[c].x,
                    y: nodes[c].y
                };
            a.push(d)
        }
        for (var b = 0; b < selectednodeindexes.length; b++) {
            var c = selectednodeindexes[b];
            nodes[c].x - nodes[c].rx >= 1 && (nodes[c].x = nodes[c].x - 1)
        }
        for (var b = 0; b < selectednodeindexes.length; b++) {
            var c = selectednodeindexes[b];
            update_edge_with_moved_node(nodes[c], a[b])
        }
    }
    if (1 === svgstatus.noteselected)
        for (var b = 0; b < selectednoteindexes.length; b++) {
            var c = selectednoteindexes[b];
            notes[c].x >= 1 && (notes[c].x = notes[c].x - 1)
        }
    updatesvg()
}

function BTNmoveright() {
    if (ResetButtonStatus(), 1 === svgstatus.nodeselected) {
        for (var a = [], b = 0; b < selectednodeindexes.length; b++) {
            var c = selectednodeindexes[b],
                d = {
                    x: nodes[c].x,
                    y: nodes[c].y
                };
            a.push(d)
        }
        for (var b = 0; b < selectednodeindexes.length; b++) {
            var c = selectednodeindexes[b];
            nodes[c].x + nodes[c].rx <= w - 1 && (nodes[c].x = nodes[c].x + 1)
        }
        for (var b = 0; b < selectednodeindexes.length; b++) {
            var c = selectednodeindexes[b];
            update_edge_with_moved_node(nodes[c], a[b])
        }
    }
    if (1 === svgstatus.noteselected)
        for (var b = 0; b < selectednoteindexes.length; b++) {
            var c = selectednoteindexes[b];
            notes[c].x <= w - 1 && (notes[c].x = notes[c].x + 1)
        }
    updatesvg()
}

function BTNwidth() {
    if (ResetButtonStatus(), 1 === svgstatus.nodeselected) {
        for (var a = nodes[selectednodeindexes[0]].rx, b = [], c = 0; c < selectednodeindexes.length; c++) {
            var d = selectednodeindexes[c],
                e = {
                    x: nodes[d].x,
                    y: nodes[d].y
                };
            b.push(e), nodes[d].rx > a && (a = nodes[d].rx)
        }
        for (var c = 0; c < selectednodeindexes.length; c++) {
            var d = selectednodeindexes[c];
            nodes[d].rx = a
        }
        for (var c = 0; c < selectednodeindexes.length; c++) {
            var d = selectednodeindexes[c];
            update_edge_with_moved_node(nodes[d], b[c])
        }
    }
    updatesvg()
}

function BTNheight() {
    if (ResetButtonStatus(), 1 === svgstatus.nodeselected) {
        for (var a = nodes[selectednodeindexes[0]].ry, b = [], c = 0; c < selectednodeindexes.length; c++) {
            var d = selectednodeindexes[c],
                e = {
                    x: nodes[d].x,
                    y: nodes[d].y
                };
            b.push(e), nodes[d].ry > a && (a = nodes[d].ry)
        }
        for (var c = 0; c < selectednodeindexes.length; c++) {
            var d = selectednodeindexes[c];
            nodes[d].ry = a
        }
        for (var c = 0; c < selectednodeindexes.length; c++) {
            var d = selectednodeindexes[c];
            update_edge_with_moved_node(nodes[d], b[c])
        }
    }
    updatesvg()
}

function BTNwidthnarrow() {
    if (ResetButtonStatus(), 1 === svgstatus.nodeselected) {
        for (var a = nodes[selectednodeindexes[0]].rx, b = [], c = 0; c < selectednodeindexes.length; c++) {
            var d = selectednodeindexes[c],
                e = {
                    x: nodes[d].x,
                    y: nodes[d].y
                };
            b.push(e), nodes[d].rx < a && (a = nodes[d].rx)
        }
        for (var c = 0; c < selectednodeindexes.length; c++) {
            var d = selectednodeindexes[c];
            nodes[d].rx = a
        }
        for (var c = 0; c < selectednodeindexes.length; c++) {
            var d = selectednodeindexes[c];
            update_edge_with_moved_node(nodes[d], b[c])
        }
    }
    updatesvg()
}

function BTNheightshort() {
    if (ResetButtonStatus(), 1 === svgstatus.nodeselected) {
        for (var a = nodes[selectednodeindexes[0]].ry, b = [], c = 0; c < selectednodeindexes.length; c++) {
            var d = selectednodeindexes[c],
                e = {
                    x: nodes[d].x,
                    y: nodes[d].y
                };
            b.push(e), nodes[d].ry < a && (a = nodes[d].ry)
        }
        for (var c = 0; c < selectednodeindexes.length; c++) {
            var d = selectednodeindexes[c];
            nodes[d].ry = a
        }
        for (var c = 0; c < selectednodeindexes.length; c++) {
            var d = selectednodeindexes[c];
            update_edge_with_moved_node(nodes[d], b[c])
        }
    }
    updatesvg()
}

function BTNecurvetopleft() {
    ResetButtonStatus(), current_selfpathTHETA = 5 / 4 * Math.PI;
    var a = !1;
    if (1 === svgstatus.edgeselected)
        for (var b = 0; b < selectededgeindexes.length; b++) {
            var c = selectededgeindexes[b];
            if (c >= 0 & c < edges.length) {
                var d = c;
                if (3 == edges[d].power) {
                    var e = edges[d].labelP.x - edges[d].handleP.x,
                        f = edges[d].labelP.y - edges[d].handleP.y,
                        g = update_bcurve3p(nodes, edges[d], current_selfpathTHETA, selfpathANGLE_default);
                    edges[d] = g, edges_tangents[d] = generate_tangent(nodes, edges[d]);
                    var h = matchnodeindex(nodes, edges[d].startid),
                        i = matchnodeindex(nodes, edges[d].endid),
                        j = {
                            x: nodes[h].x,
                            y: nodes[h].y
                        },
                        k = {
                            x: nodes[i].x,
                            y: nodes[i].y
                        },
                        l = edges[d].handleP;
                    edges[d].labelP = cal_labelP(l, j, k, edges[d].power, e, f), a = !0
                }
            }
        }
    a && updatesvg()
}

function BTNecurvetop() {
    ResetButtonStatus(), current_selfpathTHETA = 1.5 * Math.PI;
    var a = !1;
    if (1 === svgstatus.edgeselected)
        for (var b = 0; b < selectededgeindexes.length; b++) {
            var c = selectededgeindexes[b];
            if (c >= 0 & c < edges.length) {
                var d = c;
                if (3 == edges[d].power) {
                    var e = edges[d].labelP.x - edges[d].handleP.x,
                        f = edges[d].labelP.y - edges[d].handleP.y,
                        g = update_bcurve3p(nodes, edges[d], current_selfpathTHETA, selfpathANGLE_default);
                    edges[d] = g, edges_tangents[d] = generate_tangent(nodes, edges[d]);
                    var h = matchnodeindex(nodes, edges[d].startid),
                        i = matchnodeindex(nodes, edges[d].endid),
                        j = {
                            x: nodes[h].x,
                            y: nodes[h].y
                        },
                        k = {
                            x: nodes[i].x,
                            y: nodes[i].y
                        },
                        l = edges[d].handleP;
                    edges[d].labelP = cal_labelP(l, j, k, edges[d].power, e, f), a = !0
                }
            }
        }
    a && updatesvg()
}

function BTNecurvetopright() {
    ResetButtonStatus(), current_selfpathTHETA = 7 / 4 * Math.PI;
    var a = !1;
    if (1 === svgstatus.edgeselected)
        for (var b = 0; b < selectededgeindexes.length; b++) {
            var c = selectededgeindexes[b];
            if (c >= 0 & c < edges.length) {
                var d = c;
                if (3 == edges[d].power) {
                    var e = edges[d].labelP.x - edges[d].handleP.x,
                        f = edges[d].labelP.y - edges[d].handleP.y,
                        g = update_bcurve3p(nodes, edges[d], current_selfpathTHETA, selfpathANGLE_default);
                    edges[d] = g, edges_tangents[d] = generate_tangent(nodes, edges[d]);
                    var h = matchnodeindex(nodes, edges[d].startid),
                        i = matchnodeindex(nodes, edges[d].endid),
                        j = {
                            x: nodes[h].x,
                            y: nodes[h].y
                        },
                        k = {
                            x: nodes[i].x,
                            y: nodes[i].y
                        },
                        l = edges[d].handleP;
                    edges[d].labelP = cal_labelP(l, j, k, edges[d].power, e, f), a = !0
                }
            }
        }
    a && updatesvg()
}

function BTNecurveleft() {
    ResetButtonStatus(), current_selfpathTHETA = 1 * Math.PI;
    var a = !1;
    if (1 === svgstatus.edgeselected)
        for (var b = 0; b < selectededgeindexes.length; b++) {
            var c = selectededgeindexes[b];
            if (c >= 0 & c < edges.length) {
                var d = c;
                if (3 == edges[d].power) {
                    var e = edges[d].labelP.x - edges[d].handleP.x,
                        f = edges[d].labelP.y - edges[d].handleP.y,
                        g = update_bcurve3p(nodes, edges[d], current_selfpathTHETA, selfpathANGLE_default);
                    edges[d] = g, edges_tangents[d] = generate_tangent(nodes, edges[d]);
                    var h = matchnodeindex(nodes, edges[d].startid),
                        i = matchnodeindex(nodes, edges[d].endid),
                        j = {
                            x: nodes[h].x,
                            y: nodes[h].y
                        },
                        k = {
                            x: nodes[i].x,
                            y: nodes[i].y
                        },
                        l = edges[d].handleP;
                    edges[d].labelP = cal_labelP(l, j, k, edges[d].power, e, f), a = !0
                }
            }
        }
    a && updatesvg()
}

function BTNecurveright() {
    ResetButtonStatus(), current_selfpathTHETA = 2 * Math.PI;
    var a = !1;
    if (1 === svgstatus.edgeselected)
        for (var b = 0; b < selectededgeindexes.length; b++) {
            var c = selectededgeindexes[b];
            if (c >= 0 & c < edges.length) {
                var d = c;
                if (3 == edges[d].power) {
                    var e = edges[d].labelP.x - edges[d].handleP.x,
                        f = edges[d].labelP.y - edges[d].handleP.y,
                        g = update_bcurve3p(nodes, edges[d], current_selfpathTHETA, selfpathANGLE_default);
                    edges[d] = g, edges_tangents[d] = generate_tangent(nodes, edges[d]);
                    var h = matchnodeindex(nodes, edges[d].startid),
                        i = matchnodeindex(nodes, edges[d].endid),
                        j = {
                            x: nodes[h].x,
                            y: nodes[h].y
                        },
                        k = {
                            x: nodes[i].x,
                            y: nodes[i].y
                        },
                        l = edges[d].handleP;
                    edges[d].labelP = cal_labelP(l, j, k, edges[d].power, e, f), a = !0
                }
            }
        }
    a && updatesvg()
}

function BTNecurvebottomleft() {
    ResetButtonStatus(), current_selfpathTHETA = .75 * Math.PI;
    var a = !1;
    if (1 === svgstatus.edgeselected)
        for (var b = 0; b < selectededgeindexes.length; b++) {
            var c = selectededgeindexes[b];
            if (c >= 0 & c < edges.length) {
                var d = c;
                if (3 == edges[d].power) {
                    var e = edges[d].labelP.x - edges[d].handleP.x,
                        f = edges[d].labelP.y - edges[d].handleP.y,
                        g = update_bcurve3p(nodes, edges[d], current_selfpathTHETA, selfpathANGLE_default);
                    edges[d] = g, edges_tangents[d] = generate_tangent(nodes, edges[d]);
                    var h = matchnodeindex(nodes, edges[d].startid),
                        i = matchnodeindex(nodes, edges[d].endid),
                        j = {
                            x: nodes[h].x,
                            y: nodes[h].y
                        },
                        k = {
                            x: nodes[i].x,
                            y: nodes[i].y
                        },
                        l = edges[d].handleP;
                    edges[d].labelP = cal_labelP(l, j, k, edges[d].power, e, f), a = !0
                }
            }
        }
    a && updatesvg()
}

function BTNecurvebottom() {
    ResetButtonStatus(), current_selfpathTHETA = .5 * Math.PI;
    var a = !1;
    if (1 === svgstatus.edgeselected)
        for (var b = 0; b < selectededgeindexes.length; b++) {
            var c = selectededgeindexes[b];
            if (c >= 0 & c < edges.length) {
                var d = c;
                if (3 == edges[d].power) {
                    var e = edges[d].labelP.x - edges[d].handleP.x,
                        f = edges[d].labelP.y - edges[d].handleP.y,
                        g = update_bcurve3p(nodes, edges[d], current_selfpathTHETA, selfpathANGLE_default);
                    edges[d] = g, edges_tangents[d] = generate_tangent(nodes, edges[d]);
                    var h = matchnodeindex(nodes, edges[d].startid),
                        i = matchnodeindex(nodes, edges[d].endid),
                        j = {
                            x: nodes[h].x,
                            y: nodes[h].y
                        },
                        k = {
                            x: nodes[i].x,
                            y: nodes[i].y
                        },
                        l = edges[d].handleP;
                    edges[d].labelP = cal_labelP(l, j, k, edges[d].power, e, f), a = !0
                }
            }
        }
    a && updatesvg()
}

function BTNecurvebottomright() {
    ResetButtonStatus(), current_selfpathTHETA = .25 * Math.PI;
    var a = !1;
    if (1 === svgstatus.edgeselected)
        for (var b = 0; b < selectededgeindexes.length; b++) {
            var c = selectededgeindexes[b];
            if (c >= 0 & c < edges.length) {
                var d = c;
                if (3 == edges[d].power) {
                    var e = edges[d].labelP.x - edges[d].handleP.x,
                        f = edges[d].labelP.y - edges[d].handleP.y,
                        g = update_bcurve3p(nodes, edges[d], current_selfpathTHETA, selfpathANGLE_default);
                    edges[d] = g, edges_tangents[d] = generate_tangent(nodes, edges[d]);
                    var h = matchnodeindex(nodes, edges[d].startid),
                        i = matchnodeindex(nodes, edges[d].endid),
                        j = {
                            x: nodes[h].x,
                            y: nodes[h].y
                        },
                        k = {
                            x: nodes[i].x,
                            y: nodes[i].y
                        },
                        l = edges[d].handleP;
                    edges[d].labelP = cal_labelP(l, j, k, edges[d].power, e, f), a = !0
                }
            }
        }
    a && updatesvg()
}

function BTNplusdiameterlong() {
    if (ResetButtonStatus(), current_RADIUSH >= 200);
    else {
        if (current_RADIUSH += 1, 1 === svgstatus.nodeselected)
            for (var a = 0; a < selectednodeindexes.length; a++) {
                var b = selectednodeindexes[a];
                if (b >= 0 & b < nodes.length) {
                    nodes[b].rx = current_RADIUSH;
                    for (var c = lookfor_relatededges(nodes[b].id), d = 0; d < c.length; d++) {
                        var e = c[d];
                        2 === edges[e].power ? edges[e] = update_bcurve2p(nodes, edges[e]) : 3 === edges[e].power && (edges[e] = update_bcurve3p(nodes, edges[e], edges[e].theta, selfpathANGLE_default)), edges_tangents[e] = generate_tangent(nodes, edges[e])
                    }
                }
            }
        var f = document.getElementById("textdiameterlong");
        f.value = 2 * current_RADIUSH, updatesvg()
    }
}

function BTNminusdiameterlong() {
    if (ResetButtonStatus(), current_RADIUSH <= 10);
    else {
        if (current_RADIUSH -= 1, 1 === svgstatus.nodeselected)
            for (var a = 0; a < selectednodeindexes.length; a++) {
                var b = selectednodeindexes[a];
                if (b >= 0 & b < nodes.length) {
                    nodes[b].rx = current_RADIUSH;
                    for (var c = lookfor_relatededges(nodes[b].id), d = 0; d < c.length; d++) {
                        var e = c[d];
                        2 === edges[e].power ? edges[e] = update_bcurve2p(nodes, edges[e]) : 3 === edges[e].power && (edges[e] = update_bcurve3p(nodes, edges[e], edges[e].theta, selfpathANGLE_default)), edges_tangents[e] = generate_tangent(nodes, edges[e])
                    }
                }
            }
        var f = document.getElementById("textdiameterlong");
        f.value = 2 * current_RADIUSH, updatesvg()
    }
}

function BTNplusdiametershort() {
    if (ResetButtonStatus(), current_RADIUSV >= 200);
    else {
        if (current_RADIUSV += 1, 1 === svgstatus.nodeselected)
            for (var a = 0; a < selectednodeindexes.length; a++) {
                var b = selectednodeindexes[a];
                if (b >= 0 & b < nodes.length) {
                    nodes[b].ry = current_RADIUSV;
                    for (var c = lookfor_relatededges(nodes[b].id), d = 0; d < c.length; d++) {
                        var e = c[d];
                        2 === edges[e].power ? edges[e] = update_bcurve2p(nodes, edges[e]) : 3 === edges[e].power && (edges[e] = update_bcurve3p(nodes, edges[e], edges[e].theta, selfpathANGLE_default)), edges_tangents[e] = generate_tangent(nodes, edges[e])
                    }
                }
            }
        var f = document.getElementById("textdiametershort");
        f.value = 2 * current_RADIUSV, updatesvg()
    }
}

function BTNminusdiametershort() {
    if (ResetButtonStatus(), current_RADIUSV <= 10);
    else {
        if (current_RADIUSV -= 1, 1 === svgstatus.nodeselected)
            for (var a = 0; a < selectednodeindexes.length; a++) {
                var b = selectednodeindexes[a];
                if (b >= 0 & b < nodes.length) {
                    nodes[b].ry = current_RADIUSV;
                    for (var c = lookfor_relatededges(nodes[b].id), d = 0; d < c.length; d++) {
                        var e = c[d];
                        2 === edges[e].power ? edges[e] = update_bcurve2p(nodes, edges[e]) : 3 === edges[e].power && (edges[e] = update_bcurve3p(nodes, edges[e], edges[e].theta, selfpathANGLE_default)), edges_tangents[e] = generate_tangent(nodes, edges[e])
                    }
                }
            }
        var f = document.getElementById("textdiametershort");
        f.value = 2 * current_RADIUSV, updatesvg()
    }
}

function BTNplusfont() {
    if (ResetButtonStatus(), current_FONTSIZE >= 72);
    else {
        if (current_FONTSIZE += 1, 1 === svgstatus.edgeselected)
            for (var a = 0; a < selectededgeindexes.length; a++) {
                var b = selectededgeindexes[a];
                b >= 0 & b < edges.length && (edges[b].labelFsize = current_FONTSIZE)
            }
        if (1 === svgstatus.nodeselected)
            for (var a = 0; a < selectednodeindexes.length; a++) {
                var c = selectednodeindexes[a];
                if (c >= 0 & c < nodes.length && (nodes[c].fontsize = current_FONTSIZE, nodes[c].rx <= nodes[c].title.length * nodes[c].fontsize * .5)) {
                    nodes[c].rx = nodes[c].title.length * nodes[c].fontsize * .5;
                    for (var d = lookfor_relatededges(nodes[c].id), e = 0; e < d.length; e++) {
                        var f = d[e];
                        2 === edges[f].power ? edges[f] = update_bcurve2p(nodes, edges[f]) : 3 === edges[f].power && (edges[f] = update_bcurve3p(nodes, edges[f], edges[f].theta, selfpathANGLE_default)), edges_tangents[f] = generate_tangent(nodes, edges[f])
                    }
                }
            }
        if (1 === svgstatus.noteselected)
            for (var a = 0; a < selectednoteindexes.length; a++) {
                var g = selectednoteindexes[a];
                g >= 0 & g < notes.length && (notes[g].fontsize = current_FONTSIZE)
            }
        tobject = document.getElementById("textfontsize"), tobject.textContent = current_FONTSIZE, updatesvg()
    }
}

function BTNminusfont() {
    if (ResetButtonStatus(), current_FONTSIZE <= 6);
    else {
        if (current_FONTSIZE -= 1, 1 === svgstatus.edgeselected)
            for (var a = 0; a < selectededgeindexes.length; a++) {
                var b = selectededgeindexes[a];
                b >= 0 & b < edges.length && (edges[b].labelFsize = current_FONTSIZE)
            }
        if (1 === svgstatus.nodeselected)
            for (var a = 0; a < selectednodeindexes.length; a++) {
                var c = selectednodeindexes[a];
                if (c >= 0 & c < nodes.length && (nodes[c].fontsize = current_FONTSIZE, nodes[c].rx <= nodes[c].title.length * nodes[c].fontsize * .5)) {
                    nodes[c].rx = nodes[c].title.length * nodes[c].fontsize * .5;
                    for (var d = lookfor_relatededges(nodes[c].id), e = 0; e < d.length; e++) {
                        var f = d[e];
                        2 === edges[f].power ? edges[f] = update_bcurve2p(nodes, edges[f]) : 3 === edges[f].power && (edges[f] = update_bcurve3p(nodes, edges[f], edges[f].theta, selfpathANGLE_default)), edges_tangents[f] = generate_tangent(nodes, edges[f])
                    }
                }
            }
        if (1 === svgstatus.noteselected)
            for (var a = 0; a < selectednoteindexes.length; a++) {
                var g = selectednoteindexes[a];
                g >= 0 & g < notes.length && (notes[g].fontsize = current_FONTSIZE)
            }
        tobject = document.getElementById("textfontsize"), tobject.textContent = current_FONTSIZE, updatesvg()
    }
}

function BTNplusstroke() {
    if (ResetButtonStatus(), current_strokeWIDTH >= 5);
    else {
        if (current_strokeWIDTH += .5, 1 === svgstatus.edgeselected)
            for (var a = 0; a < selectededgeindexes.length; a++) {
                var b = selectededgeindexes[a];
                b >= 0 & b < edges.length && (edges[b].strokewidth = current_strokeWIDTH)
            }
        if (1 === svgstatus.nodeselected)
            for (var a = 0; a < selectednodeindexes.length; a++) {
                var c = selectednodeindexes[a];
                c >= 0 & c < nodes.length && (nodes[c].strokewidth = current_strokeWIDTH)
            }
        var d = document.getElementById("textstrokewidth");
        d.value = current_strokeWIDTH, updatesvg()
    }
}

function BTNminusstroke() {
    if (ResetButtonStatus(), current_strokeWIDTH <= .5);
    else {
        if (current_strokeWIDTH -= .5, 1 === svgstatus.edgeselected)
            for (var a = 0; a < selectededgeindexes.length; a++) {
                var b = selectededgeindexes[a];
                b >= 0 & b < edges.length && (edges[b].strokewidth = current_strokeWIDTH)
            }
        if (1 === svgstatus.nodeselected)
            for (var a = 0; a < selectednodeindexes.length; a++) {
                var c = selectednodeindexes[a];
                c >= 0 & c < nodes.length && (nodes[c].strokewidth = current_strokeWIDTH)
            }
        var d = document.getElementById("textstrokewidth");
        d.value = current_strokeWIDTH, updatesvg()
    }
}

function BTNplusecurve() {
    if (ResetButtonStatus(), current_selfcurve_LR >= 81);
    else {
        current_selfcurve_LR += 1;
        default_selfcurve_LR;
        if (1 === svgstatus.edgeselected)
            for (var b = 0; b < selectededgeindexes.length; b++) {
                var c = selectededgeindexes[b];
                if (c >= 0 & c < edges.length) {
                    var d = edges[c];
                    3 === d.power && (d.curve_LR = current_selfcurve_LR, edges[c] = update_bcurve(nodes, d), edges[c].selected = !0)
                }
            }
        var e = document.getElementById("textecurvesize");
        e.value = current_selfcurve_LR, updatesvg()
    }
}

function BTNminusecurve() {
    if (ResetButtonStatus(), current_selfcurve_LR <= 27);
    else {
        current_selfcurve_LR -= 1;
        default_selfcurve_LR;
        if (1 === svgstatus.edgeselected)
            for (var b = 0; b < selectededgeindexes.length; b++) {
                var c = selectededgeindexes[b];
                if (c >= 0 & c < edges.length) {
                    var d = edges[c];
                    3 === d.power && (d.curve_LR = current_selfcurve_LR, edges[c] = update_bcurve(nodes, d), edges[c].selected = !0)
                }
            }
        var e = document.getElementById("textecurvesize");
        e.value = current_selfcurve_LR, updatesvg()
    }
}

function BTNfontsize() {
    if (ResetButtonStatus(), 1 === svgstatus.edgeselected)
        for (var a = 0; a < selectededgeindexes.length; a++) {
            var b = selectededgeindexes[a];
            b >= 0 & b < edges.length && (edges[b].labelFsize = current_FONTSIZE)
        }
    if (1 === svgstatus.nodeselected)
        for (var a = 0; a < selectednodeindexes.length; a++) {
            var c = selectednodeindexes[a];
            if (c >= 0 & c < nodes.length && (nodes[c].fontsize = current_FONTSIZE, nodes[c].rx <= nodes[c].title.length * nodes[c].fontsize * .5)) {
                nodes[c].rx = nodes[c].title.length * nodes[c].fontsize * .5;
                for (var d = lookfor_relatededges(nodes[c].id), e = 0; e < d.length; e++) {
                    var f = d[e];
                    2 === edges[f].power ? edges[f] = update_bcurve2p(nodes, edges[f]) : 3 === edges[f].power && (edges[f] = update_bcurve3p(nodes, edges[f], edges[f].theta, selfpathANGLE_default)), edges_tangents[f] = generate_tangent(nodes, edges[f])
                }
            }
        }
    if (1 === svgstatus.noteselected)
        for (var a = 0; a < selectednoteindexes.length; a++) {
            var g = selectednoteindexes[a];
            g >= 0 & g < notes.length && (notes[g].fontsize = current_FONTSIZE)
        }
    updatesvg()
}

function BTNstrokewidth() {
    ResetButtonStatus();
    var a = document.getElementById("textstrokewidth");
    if (current_strokeWIDTH = Number(a.value), 1 === svgstatus.edgeselected)
        for (var b = 0; b < selectededgeindexes.length; b++) {
            var c = selectededgeindexes[b];
            c >= 0 & c < edges.length && (edges[c].strokewidth = current_strokeWIDTH)
        }
    if (1 === svgstatus.nodeselected)
        for (var b = 0; b < selectednodeindexes.length; b++) {
            var d = selectednodeindexes[b];
            d >= 0 & d < nodes.length && (nodes[d].strokewidth = current_strokeWIDTH)
        }
    updatesvg()
}

function BTNecurvesize() {
    ResetButtonStatus();
    var a = document.getElementById("textecurvesize");
    if (current_selfcurve_LR = Number(a.value), 1 === svgstatus.edgeselected)
        for (var b = 0; b < selectededgeindexes.length; b++) {
            var c = selectededgeindexes[b];
            if (c >= 0 & c < edges.length) {
                var d = edges[c];
                3 === d.power && (d.curve_LR = current_selfcurve_LR, edges[c] = update_bcurve(nodes, d), edges[c].selected = !0)
            }
        }
    updatesvg()
}

function BTNdiameterlong() {
    ResetButtonStatus();
    var a = document.getElementById("textdiameterlong");
    if (current_RADIUSH = Number(a.value) / 2, 1 === svgstatus.nodeselected)
        for (var b = 0; b < selectednodeindexes.length; b++) {
            var c = selectednodeindexes[b];
            if (c >= 0 & c < nodes.length) {
                nodes[c].rx = current_RADIUSH;
                for (var d = lookfor_relatededges(nodes[c].id), e = 0; e < d.length; e++) {
                    var f = d[e];
                    2 === edges[f].power ? edges[f] = update_bcurve2p(nodes, edges[f]) : 3 === edges[f].power && (edges[f] = update_bcurve3p(nodes, edges[f], edges[f].theta, selfpathANGLE_default)), edges_tangents[f] = generate_tangent(nodes, edges[f])
                }
            }
        }
    var a = document.getElementById("textdiameterlong");
    a.value = 2 * current_RADIUSH, updatesvg()
}

function BTNdiametershort() {
    ResetButtonStatus();
    var a = document.getElementById("textdiametershort");
    if (current_RADIUSV = Number(a.value) / 2, 1 === svgstatus.nodeselected)
        for (var b = 0; b < selectednodeindexes.length; b++) {
            var c = selectednodeindexes[b];
            if (c >= 0 & c < nodes.length) {
                nodes[c].ry = current_RADIUSV;
                for (var d = lookfor_relatededges(nodes[c].id), e = 0; e < d.length; e++) {
                    var f = d[e];
                    2 === edges[f].power ? edges[f] = update_bcurve2p(nodes, edges[f]) : 3 === edges[f].power && (edges[f] = update_bcurve3p(nodes, edges[f], edges[f].theta, selfpathANGLE_default)),
                        edges_tangents[f] = generate_tangent(nodes, edges[f])
                }
            }
        }
    var a = document.getElementById("textdiametershort");
    a.value = 2 * current_RADIUSV, updatesvg()
}

function textfontsize() {
    oTextarea = document.getElementById("textfontsize"), Number(oTextarea.value) <= 72 && Number(oTextarea.value) >= 6 ? (current_FONTSIZE = Number(oTextarea.value), BTNfontsize()) : oTextarea.value = 12
}

function textstrokewidth() {
    oTextarea = document.getElementById("textstrokewidth"), Number(oTextarea.value) <= 5 && Number(oTextarea.value) >= .5 ? (current_strokeWIDTH = Number(oTextarea.value), BTNstrokewidth()) : oTextarea.value = 1
}

function textecurvesize() {
    oTextarea = document.getElementById("textecurvesize"), Number(oTextarea.value) <= 81 && Number(oTextarea.value) >= 27 ? (current_selfcurve_LR = Number(oTextarea.value), BTNecurvesize()) : oTextarea.value = default_selfcurve_LR
}

function textdiameterlong() {
    oTextarea = document.getElementById("textdiameterlong"), Number(oTextarea.value) <= 400 && Number(oTextarea.value) >= 20 ? (current_RADIUSH = Number(oTextarea.value), BTNdiameterlong()) : oTextarea.value = 2 * default_RADIUSH
}

function textdiametershort() {
    oTextarea = document.getElementById("textdiametershort"), Number(oTextarea.value) <= 400 && Number(oTextarea.value) >= 20 ? (current_RADIUSV = Number(oTextarea.value), BTNdiametershort()) : oTextarea.value = 2 * default_RADIUSV
}

function getSelectValue_FontSize() {
    ResetButtonStatus();
    var a = document.getElementById("selectfontsize"),
        b = Number(a.options[a.selectedIndex].value);
    if (1 === svgstatus.edgeselected)
        for (var c = 0; c < selectededgeindexes.length; c++) {
            var d = selectededgeindexes[c];
            d >= 0 & d < edges.length && (edges[d].labelFsize = b)
        }
    if (1 === svgstatus.nodeselected)
        for (var c = 0; c < selectednodeindexes.length; c++) {
            var e = selectednodeindexes[c];
            if (e >= 0 & e < nodes.length && (nodes[e].fontsize = b, nodes[e].rx <= nodes[e].title.length * nodes[e].fontsize * .5)) {
                nodes[e].rx = nodes[e].title.length * nodes[e].fontsize * .5;
                for (var f = lookfor_relatededges(nodes[e].id), c = 0; c < f.length; c++) {
                    var g = f[c];
                    2 === edges[g].power ? edges[g] = update_bcurve2p(nodes, edges[g]) : 3 === edges[g].power && (edges[g] = update_bcurve3p(nodes, edges[g], edges[g].theta, selfpathANGLE_default)), edges_tangents[g] = generate_tangent(nodes, edges[g])
                }
            }
        }
    if (1 === svgstatus.noteselected)
        for (var c = 0; c < selectednoteindexes.length; c++) {
            var h = selectednoteindexes[c];
            h >= 0 & h < notes.length && (notes[h].fontsize = b)
        }
    a.selectedIndex = 0, a.value = Number(a.options[a.selectedIndex].value), updatesvg()
}

function getSelectValue_ErrorCurveSize() {
    ResetButtonStatus();
    var a = document.getElementById("selectErrorCurveSize"),
        b = default_selfcurve_LR;
    if (a && (b = a.value), 1 === svgstatus.edgeselected)
        for (var c = 0; c < selectededgeindexes.length; c++) {
            var d = selectededgeindexes[c];
            if (d >= 0 & d < edges.length) {
                var e = edges[d];
                3 === e.power && (e.curve_LR = b, edges[d] = update_bcurve(nodes, e), edges[d].selected = !0)
            }
        }
    a.selectedIndex = 0, a.value = Number(a.options[a.selectedIndex].value), updatesvg()
}

function getSelectValue_LineWidth() {
    ResetButtonStatus();
    var a = document.getElementById("selectLineWidth"),
        b = default_strokeWIDTH;
    if (a.value && (b = a.value), 1 === svgstatus.edgeselected)
        for (var c = 0; c < selectededgeindexes.length; c++) {
            var d = selectededgeindexes[c];
            d >= 0 & d < edges.length && (edges[d].strokewidth = b)
        }
    if (1 === svgstatus.nodeselected)
        for (var c = 0; c < selectednodeindexes.length; c++) {
            var e = selectednodeindexes[c];
            e >= 0 & e < nodes.length && (nodes[e].strokewidth = b)
        }
    a.selectedIndex = 0, a.value = Number(a.options[a.selectedIndex].value), updatesvg()
}

function getSelectValue_ChartSize() {
    ResetButtonStatus();
    var a = document.getElementById("selectChartSize");
    switch (a.value) {
        case "small":
            w = 2e3, h = 2e3, mysvg.attr("width", w).attr("height", h);
            break;
        case "medium":
            w = 3e3, h = 3e3, mysvg.attr("width", w).attr("height", h);
            break;
        case "large":
            w = 5e3, h = 5e3, mysvg.attr("width", w).attr("height", h);
            break;
        default:
            w = 1e3, h = 1200, mysvg.attr("width", w).attr("height", h)
    }
    a.selectedIndex = 0, a.value = Number(a.options[a.selectedIndex].value), updatesvg()
}

function BTNSAVE() {
    // try {
    //     var a = diagName,
    //         b = GraphToText2();
    //     $("#inputnamedialog") && $("#inputnamedialog").remove();
    //     var c = document.createElement("div");
    //     c.id = "inputnamedialog", c.style.color = "black";
    //     var d = document.createElement("div");
    //     d.style = "width=230px; height=100px";
    //     var e = document.createElement("form");
    //     e.id = "inputnameform";
    //     var f = document.createElement("input");
    //     f.id = "nameinput", f.type = "text", f.name = "text", f.style = "width=200px; height=50px", f.contentEditable = !0, f.value = a, f.focus(), $(f).keydown(function (b) {
    //         if (a = f.value, 13 == b.keyCode || 13 == b.witch) return b.preventDefault(), $(g).click(), !1
    //     }), e.appendChild(f), d.appendChild(e);
    //     var g = document.createElement("button");
    //     g.innerHTML = "OK", g.id = "dialogbuton1", $(g).click(function () {
    //         a = f.value, diagName = a, $.download("http://semdiag.psychstat.org/download.php", "filename===" + a + "&filecontent===" + b + "&filetype===diag"), $(c).dialog("close"), $("#inputnamedialog").remove()
    //     }), d.appendChild(g);
    //     var h = document.createElement("button");
    //     h.innerHTML = "Cancel", h.id = "dialogbuton2", h.styles = "margin-left:2px", $(h).click(function () {
    //         $(c).dialog("close"), $("#inputnamedialog").remove()
    //     }), d.appendChild(h), c.appendChild(d), $(c).dialog({
    //         modal: !0,
    //         title: "Save Diagram",
    //         width: "230",
    //         height: "130",
    //         bgiframe: !0,
    //         closeOnEscape: !0,
    //         draggable: !0,
    //         resizable: !0
    //     })
    // } catch (a) {
    //     alert("SAVE:" + a)
    // }
    var a = prompt("Enter file name","diagram");
    var b = GraphToText2();
    var blob =blob = new Blob([b.toString()]);
    var element = document.createElement("a");
    element.download = a+".diag";
    element.href = window.URL.createObjectURL(blob);
    element.click();
    element.remove();
}

function svgRender(a) {
    var b = a.nodes,
        c = a.edges,
        d = a.notes,
        e = a.marks;
    Nodecurrent_IdNUM = e.Nodecurrent_IdNUM, Edgecurrent_IdNUM = e.Edgecurrent_IdNUM, Elli_current_TitleNUM = e.Elli_current_TitleNUM, Rec_current_TitleNUM = e.Rec_current_TitleNUM, h = e.h, w = e.w, nodes = b, edges = c, edges_tangents = [], edges_tangents = generate_tangents(nodes, edges), notes = d, ellipsenodes = nodes.filter(function (a) {
        return "ellipse" == a.type
    }), rectnodes = nodes.filter(function (a) {
        return "rect" == a.type
    }), trianglenodes = nodes.filter(function (a) {
        return "triangle" == a.type
    }), numRec = rectnodes.length, numElli = ellipsenodes.length, numTri = trianglenodes.length, numNode = nodes.length, numEdge = edges.length, numNote = notes.length, numTri > 0 && (theTriangle = trianglenodes[0]), updatesvg()
}




function BTNLOAD() {
    var a = "",
        b = "";
    $("#uploadfiledialog") && $("#uploadfiledialog").remove();
    var c = document.createElement("div");
    c.id = "uploadfiledialog";
    var d = document.createElement("div");
    d.id = "inputdiv", d.style = "width:280px";
    var e = document.createElement("input");
    e.id = "inputfile", e.type = "file", e.style = "width:280px", d.appendChild(e), c.appendChild(d), $(c).dialog({
        modal: !0,
        title: "Select diagram",
        width: "400",
        height: "100",
        bgiframe: !0,
        closeOnEscape: !0,
        draggable: !0,
        resizable: !1
    }), d3.select("#inputfile").on("change", function () {
        var d = this.files,
            e = d[0],
            f = e.name;
        f.substr(0, f.length);
        var g = f.substr(f.length - 5, f.length);
        if (e)
            if (".diag" != g) alert(e.name + " is not a diagram file.");
            else {
                a = f.replace(".diag", "");
                var h = new FileReader;
                h.onload = function (d) {
                    return function (d) {
                        var e = "";
                        if (e = d.target.result, b = e, $(c).dialog("close"), $("#uploadfiledialog").remove(), "" == a);
                        else try {
                            console.log(b);
                            var f = GraphFromText2(b);
                            console.log(f);
                            0 == f.nodes.length || (svgRender(f), diagName = a)
                        } catch (a) {
                            alert("LOAD: rendering" + a)
                        }
                    }
                }(e), h.readAsText(e, "UTF-8")
            }
        else alert("Failed to load the file."), $(c).dialog("close"), $("#uploadfiledialog").remove()
    })
}

function BTNNEW() {
    var a = !0;
    a && (diagName = "", nodes = [], edges = [], edges_tangents = [], notes = [], numRec = 0, numElli = 0, numTri = 0, numNode = 0, numEdge = 0, numnote = 0, Nodecurrent_IdNUM = 0, Elli_current_TitleNUM = 0, Rec_current_TitleNUM = 0, Edgecurrent_IdNUM = 0, newnodeInitialPos_rect = {
        x: nodeInitialPos_rect.x,
        y: nodeInitialPos_rect.y
    }, newnodeInitialPos_ellipse = {
        x: nodeInitialPos_ellipse.x,
        y: nodeInitialPos_ellipse.y
    }, theTriangle = null, ellipsenodes = null, rectnodes = null, trianglenodes = null, h = 2e3, w = 2e3, svgstatus = {
        svgondragged: 0,
        nodeondragged: 0,
        nodeselected: 0,
        pathselected: 0,
        labelselected: 0,
        noteselected: 0,
        linkingto: 0,
        texting: 0,
        IsShowLabels: !0,
        IsShowGrid: !0
    }, svgdragline = {
        x0: 0,
        y0: 0,
        x1: 0,
        y1: 0
    }, justmousedownnodeindex = -1, justmousedownedgeindex = -1, justmousedownnoteindex = -1, predraggedindex = -1, selectednodeindex = -1, selectededgeindex = -1, selectednoteindex = -1, linkinginitialindex = -1, linkingtargetindex = -1, selcetedBTNID = "", mouseLastclickOBJETid, mouseCurrentclickOBJETid, mouseLastclicktime = null, mouseCurrentclicktime = null, mysvgG = null, mysvgG_foreignObject = null, pathGs = null, handleGs = null, nodeGs = null, ellipseGs = null, rectGs = null, triangleGs = null, paths = null, handlePs = null, labelTs = null, ellipses = null, rects = null, triangles = null, nodetexts = null, noteTs = null, updatesvg())
}

function BTNGraphToSVG() {
    var a = prompt("Enter file name","diagram");
        var b = GraphToSVG(nodes, edges, edges_tangents, notes);
        var blob =blob = new Blob([b.toString()]);
        var element = document.createElement("a");
        element.download = a+".svg";
        element.href = window.URL.createObjectURL(blob);
        element.click();
        element.remove();
    // $.download("http://semdiag.psychstat.org/download.php", "filename===" + a + "&filecontent===" + b + "&filetype===svg")
}

function BTNGraphToPDF() {
    var a = prompt("Enter file name","diagram");
    var b = GraphToSVGforPDF(nodes, edges, edges_tangents, notes);
    // var b =document.getElementById('svgmain');
    var wrapper= document.createElement('div');
    wrapper.innerHTML= b;
    var b= wrapper.firstChild;

    // window.jsPDF = window.jspdf.jsPDF;

    // arch=document.getElementById('svgmain');
    // updatesvg();
    // arch2=document.getElementById('svgmain');

    var tempchartsize = AdjustChartSize(nodes, edges, edges_tangents, notes);
    var tw=tempchartsize.w;
	var th=tempchartsize.h;		

    console.log(tw, th)


    // Document 
    var tmpPdf;

    if (tw>th){
        tmpPdf = new jsPDF('l', 'pt', [tw, th]);
    }else{
        tmpPdf = new jsPDF('p', 'pt',[th, tw]);
    }
    
    // tmpPdf = new jsPDF('p', 'mm', [1500, 1500]);

    // var tmpPdf = new jsPDF('l', 'pt','letter',[1000, 1000]);


    //console.log(document.getElementsByTagName('svg')[0]);

    //document.getElementById('svgcontainer').getElementsByTagName('svg')[0]
    // b=document.getElementById('svgmain');
    svg2pdf(b, tmpPdf, {
        xOffset: 0,
        yOffset: 0,
        scale: 1
    });

  
    tmpPdf.save(a+".pdf");

    // if(arch!=arch2){
    //     updatesvgmath();
    // }
    
    //svgToPdfExample(b);
   

    // var a = prompt("Enter file name","diagram");
    // var b = GraphToSVG(nodes, edges, edges_tangents, notes);
    // svgToPng(b,(imgData)=>{
    //         var pngImage = document.createElement('img');
    //         //document.body.appendChild(pngImage);
    //         pngImage.src=imgData;
    //         var element = document.createElement("a");
    //         element.download = a+".png";
    //        //element.href = window.URL.createObjectURL(imgData);
    //        window.jsPDF = window.jspdf.jsPDF;
    //        var pdf = new jsPDF();
    //        pdf.addImage(imgData, 'PNG', 0, 0);
    //        pdf.save(a+".pdf");
    //        document.getElementById("unique1").remove();
            
    // });
    // $.download("http://semdiag.psychstat.org/download.php", "filename===" + a + "&filecontent===" + b + "&filetype===svg")
}


function svgToPng(svg, callback) {
    const url = getSvgUrl(svg);
    svgUrlToPng(url, (imgData) => {
        callback(imgData);
        URL.revokeObjectURL(url);
    });
}
function getSvgUrl(svg) {
    return  URL.createObjectURL(new Blob([svg], { type: 'image/svg+xml' }));
}
function svgUrlToPng(svgUrl, callback) {
    var svgImage = document.createElement('img');
    svgImage.setAttribute("id", "unique1");
    // imgPreview.style.position = 'absolute';
    // imgPreview.style.top = '-9999px';
    document.body.appendChild(svgImage);
    svgImage.onload = function () {
        const canvas = document.createElement('canvas');
        canvas.width = svgImage.clientWidth;
        canvas.height = svgImage.clientHeight;
        const canvasCtx = canvas.getContext('2d');
        canvasCtx.drawImage(svgImage, 0, 0);
        const imgData = canvas.toDataURL('image/png');
        callback(imgData);
        // document.body.removeChild(imgPreview);
    };
    svgImage.src = svgUrl;
 }


function BTNGraphToPNG() {
    var a = prompt("Enter file name","diagram");
        var b = GraphToSVG(nodes, edges, edges_tangents, notes);
        svgToPng(b,(imgData)=>{
            var pngImage = document.createElement('img');
            //document.body.appendChild(pngImage);
            pngImage.src=imgData;
            var element = document.createElement("a");
            element.download = a+".png";
           //element.href = window.URL.createObjectURL(imgData);
            element.href = imgData;
            element.click();
            element.remove();
            document.getElementById("unique1").remove();
            
        });
       
    // $.download("http://semdiag.psychstat.org/download.php", "filename===" + a + "&filecontent===" + b + "&filetype===svg")
}

function BTNrenderMATH() {
    updatesvgmath()
}

function BTNtoMATH() {
    var a = GraphToMATH(nodes, edges, edges_tangents, notes),
        b = prompt("Enter file name","diagram");
        var blob =blob = new Blob([a.toString()]);
        var element = document.createElement("a");
        element.download = b+".html";
        element.href = window.URL.createObjectURL(blob);
        element.click();
        element.remove();
    // $.download("http://semdiag.psychstat.org/download.php", "filename===" + b + "&filecontent===" + a + "&filetype===html")
}
jQuery.download = function (a, b, c) {
    if (a && b) {
        b = "string" == typeof b ? b : jQuery.param(b);
        var d = "";
        jQuery.each(b.split("&"), function () {
            var a = this.split("===");
            d += '<input type="hidden" name="' + a[0] + '" value="' + a[1] + '" />'
        }), jQuery('<form action="' + a + '" method="' + (c || "post") + '">' + d + "</form>").appendTo("body").submit().remove()
    }
}, d3.select("#BTNrect").on("click", function () {
    selcetedBTNID = "BTNrect", d3.event.stopPropagation(), BTNrect()
}), d3.select("#BTNellipse").on("click", function () {
    selcetedBTNID = "BTNellipse", d3.event.stopPropagation(), BTNellipse()
}), d3.select("#BTNtriangle").on("click", function () {
    selcetedBTNID = "BTNtriangle", d3.event.stopPropagation(), BTNtriangle()
}), d3.select("#BTNlinkto").on("click", function () {
    selcetedBTNID = "BTNlinkto", d3.event.stopPropagation(), BTNlinkingto()
}), d3.select("#BTNlinktobi").on("click", function () {
    selcetedBTNID = "BTNlinktobi", d3.event.stopPropagation(), BTNlinkingto2()
}), d3.select("#BTNtexting").on("click", function () {
    selcetedBTNID = "BTNtexting", d3.event.stopPropagation(), BTNtexting()
}), d3.select("#BTNDEL").on("click", function () {
    selcetedBTNID = "BTNDEL", d3.event.stopPropagation(), BTNdel()
}), d3.select("#BTNclone").on("click", function () {
    selcetedBTNID = "BTNclone", d3.event.stopPropagation(), BTNclone()
}), d3.select("#BTNBLACK").on("click", function () {
    selcetedBTNID = "BTNBLACK", d3.event.stopPropagation(), BTNblack()
}), d3.select("#BTNRED").on("click", function () {
    selcetedBTNID = "BTNRED", d3.event.stopPropagation(), BTNred()
}), d3.select("#BTNGREEN").on("click", function () {
    selcetedBTNID = "BTNGREEN", d3.event.stopPropagation(), BTNgreen()
}), d3.select("#BTNBLUE").on("click", function () {
    selcetedBTNID = "BTNBLUE", d3.event.stopPropagation(), BTNblue()
}), d3.select("#BTNSOLID").on("click", function () {
    selcetedBTNID = "BTNSOLID", d3.event.stopPropagation(), BTNsolid()
}), d3.select("#BTNDOTTED").on("click", function () {
    selcetedBTNID = "BTNDOTTED", d3.event.stopPropagation(), BTNdotted()
}), d3.select("#BTNalignleft").on("click", function () {
    selcetedBTNID = "BTNalignleft", d3.event.stopPropagation(), BTNalignleft()
}), d3.select("#BTNalignright").on("click", function () {
    selcetedBTNID = "BTNalignright", d3.event.stopPropagation(), BTNalignright()
}), d3.select("#BTNaligntop").on("click", function () {
    selcetedBTNID = "BTNaligntop", d3.event.stopPropagation(), BTNaligntop()
}), d3.select("#BTNalignbottom").on("click", function () {
    selcetedBTNID = "BTNalignbottom", d3.event.stopPropagation(), BTNalignbottom()
}), d3.select("#BTNwidth").on("click", function () {
    selcetedBTNID = "BTNwidth", d3.event.stopPropagation(), BTNwidth()
}), d3.select("#BTNheight").on("click", function () {
    selcetedBTNID = "BTNheight", d3.event.stopPropagation(), BTNheight()
}), d3.select("#BTNwidthnarrow").on("click", function () {
    selcetedBTNID = "BTNwidthnarrow", d3.event.stopPropagation(), BTNwidthnarrow()
}), d3.select("#BTNheightshort").on("click", function () {
    selcetedBTNID = "BTNheightshort", d3.event.stopPropagation(), BTNheightshort()
}), d3.select("#BTNecurvetopleft").on("click", function () {
    selcetedBTNID = "BTNecurvetopleft", d3.event.stopPropagation(), BTNecurvetopleft()
}), d3.select("#BTNecurvetop").on("click", function () {
    selcetedBTNID = "BTNecurvetop", d3.event.stopPropagation(), BTNecurvetop()
}), d3.select("#BTNecurvetopright").on("click", function () {
    selcetedBTNID = "BTNecurvetopright", d3.event.stopPropagation(), BTNecurvetopright()
}), d3.select("#BTNecurveleft").on("click", function () {
    selcetedBTNID = "BTNecurveleft", d3.event.stopPropagation(), BTNecurveleft()
}), d3.select("#BTNecurveright").on("click", function () {
    selcetedBTNID = "BTNecurveright", d3.event.stopPropagation(), BTNecurveright()
}), d3.select("#BTNecurvebottomleft").on("click", function () {
    selcetedBTNID = "BTNecurvebottomleft", d3.event.stopPropagation(), BTNecurvebottomleft()
}), d3.select("#BTNecurvebottom").on("click", function () {
    selcetedBTNID = "BTNecurvebottom", d3.event.stopPropagation(), BTNecurvebottom()
}), d3.select("#BTNecurvebottomright").on("click", function () {
    selcetedBTNID = "BTNecurvebottomright", d3.event.stopPropagation(), BTNecurvebottomright()
}), d3.select("#BTNmoveup").on("click", function () {
    selcetedBTNID = "BTNmoveup", d3.event.stopPropagation(), BTNmoveup()
}), d3.select("#BTNmovedown").on("click", function () {
    selcetedBTNID = "BTNmovedown", d3.event.stopPropagation(), BTNmovedown()
}), d3.select("#BTNmoveleft").on("click", function () {
    selcetedBTNID = "BTNmoveleft", d3.event.stopPropagation(), BTNmoveleft()
}), d3.select("#BTNmoveright").on("click", function () {
    selcetedBTNID = "BTNmoveright", d3.event.stopPropagation(), BTNmoveright()
}), d3.select("#BTNplusfont").on("click", function () {
    selcetedBTNID = "BTNplusfont", d3.event.stopPropagation(), BTNplusfont()
}), d3.select("#BTNminusfont").on("click", function () {
    selcetedBTNID = "BTNminusfont", d3.event.stopPropagation(), BTNminusfont()
}), d3.select("#BTNplusstroke").on("click", function () {
    selcetedBTNID = "BTNplusstroke", d3.event.stopPropagation(), BTNplusstroke()
}), d3.select("#BTNminusstroke").on("click", function () {
    selcetedBTNID = "BTNminusstroke", d3.event.stopPropagation(), BTNminusstroke()
}), d3.select("#BTNplusecurve").on("click", function () {
    selcetedBTNID = "BTNplusecurve", d3.event.stopPropagation(), BTNplusecurve()
}), d3.select("#BTNminusecurve").on("click", function () {
    selcetedBTNID = "BTNminusecurve", d3.event.stopPropagation(), BTNminusecurve()
}), d3.select("#BTNplusdiameterlong").on("click", function () {
    selcetedBTNID = "BTNplusdiameterlong", d3.event.stopPropagation(), BTNplusdiameterlong()
}), d3.select("#BTNminusdiameterlong").on("click", function () {
    selcetedBTNID = "BTNminusdiameterlong", d3.event.stopPropagation(), BTNminusdiameterlong()
}), d3.select("#BTNplusdiametershort").on("click", function () {
    selcetedBTNID = "BTNplusdiametershort", d3.event.stopPropagation(), BTNplusdiametershort()
}), d3.select("#BTNminusdiametershort").on("click", function () {
    selcetedBTNID = "BTNminusdiametershort", d3.event.stopPropagation(), BTNminusdiametershort()
}), d3.select("#BTNfontsize").on("click", function () {
    selcetedBTNID = "BTNfontsize", d3.event.stopPropagation(), BTNfontsize()
}), d3.select("#BTNstrokewidth").on("click", function () {
    selcetedBTNID = "BTNstrokewidth", d3.event.stopPropagation(), BTNstrokewidth()
}), d3.select("#BTNecurvesize").on("click", function () {
    selcetedBTNID = "BTNecurvesize", d3.event.stopPropagation(), BTNecurvesize()
}), d3.select("#BTNdiameterlong").on("click", function () {
    selcetedBTNID = "BTNdiameterlong", d3.event.stopPropagation(), BTNdiameterlong()
}), d3.select("#BTNdiametershort").on("click", function () {
    selcetedBTNID = "BTNdiametershort", d3.event.stopPropagation(), BTNdiametershort()
}), d3.select("#textfontsize").on("blur", function () {
    d3.event.stopPropagation(), textfontsize()
}), d3.select("#textstrokewidth").on("blur", function () {
    d3.event.stopPropagation(), BTNstrokewidth()
}), d3.select("#textecurvesize").on("blur", function () {
    d3.event.stopPropagation(), textecurvesize()
}), d3.select("#textdiameterlong").on("blur", function () {
    d3.event.stopPropagation(), textdiameterlong()
}), d3.select("#textdiametershort").on("blur", function () {
    d3.event.stopPropagation(), textdiametershort()
}), d3.select("#BTNLa").on("click", function () {
    selcetedBTNID = "BTNLa", d3.event.stopPropagation(), BTNla()
}), d3.select("#BTNGrid").on("click", function () {
    selcetedBTNID = "BTNGrid", d3.event.stopPropagation(), BTNgrid()
}), d3.select("#BTNload").on("click", function () {
    selcetedBTNID = "BTNload", d3.event.stopPropagation(), BTNLOAD()
}), d3.select("#BTNnew").on("click", function () {
    selcetedBTNID = "BTNnew", d3.event.stopPropagation(), BTNNEW()
}), d3.select("#BTNsave").on("click", function () {
    selcetedBTNID = "BTNGrid", d3.event.stopPropagation(), BTNSAVE()
}), d3.select("#BTNtoSVG").on("click", function () {
    selcetedBTNID = "BTNtoSVG", d3.event.stopPropagation(), BTNGraphToSVG()
}), d3.select("#BTNtoPDF").on("click", function () {
    selcetedBTNID = "BTNtoPDF", d3.event.stopPropagation(), BTNGraphToPDF()
}), d3.select("#BTNtoPNG").on("click", function () {
    selcetedBTNID = "BTNtoPNG", d3.event.stopPropagation(), BTNGraphToPNG()
}), d3.select("#BTNrenderMATH").on("click", function () {
    selcetedBTNID = "BTNrenderMATH", d3.event.stopPropagation(), BTNrenderMATH()
}), d3.select("#BTNtoMATH").on("click", function () {
    selcetedBTNID = "BTNtorMATH", d3.event.stopPropagation(), BTNtoMATH()
});


